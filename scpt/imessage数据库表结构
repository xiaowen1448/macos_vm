1. 核心关联表
表名	与 message 的关系	作用
handle	message.handle_id → handle.ROWID	联系人信息（手机号或 Apple ID）
attachment	通过 message_attachment_join 关联	附件信息（图片、视频、文件）
message_attachment_join	message.ROWID → message_attachment_join.message_id	中间表，建立消息与附件的多对多关系
chat	chat_message_join.chat_id → chat.ROWID	聊天会话信息（群聊或单聊）
chat_message_join	chat_message_join.message_id → message.ROWID	中间表，将消息归属到聊天会话
chat_handle_join	chat_handle_join.chat_id → chat.ROWID	群聊成员表，将联系人与群聊关联
message_summary_info	message_summary_info.message_id → message.ROWID	一些摘要信息，如表情、撤回状态等

2. 辅助表
表名	作用
attachment_summary	附件摘要信息，可能用于快速索引
message_image	对部分图片的缩略图索引
message_attachment	旧版本中可能存在，用于关联附件
message_summary	消息摘要或搜索优化信息
chat_summary	会话摘要信息，如最后一条消息、未读数
message_action	消息操作记录（撤回、编辑等）

查询思路

文本消息 + 联系人 → message + handle

消息附件 → message + message_attachment_join + attachment

会话信息 → message + chat_message_join + chat

群聊成员 → chat + chat_handle_join + handle

消息摘要/状态 → message_summary_info 或 message_action


查看表结构

.schema message
CREATE TABLE message (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, guid TEXT UNIQUE NOT NULL, text TEXT, replace INTEGER DEFAULT 0, service_center TEXT, handle_id INTEGER DEFAULT 0, subject TEXT, country TEXT, attributedBody BLOB, version INTEGER DEFAULT 0, type INTEGER DEFAULT 0, service TEXT, account TEXT, account_guid TEXT, error INTEGER DEFAULT 0, date INTEGER, date_read INTEGER, date_delivered INTEGER, is_delivered INTEGER DEFAULT 0, is_finished INTEGER DEFAULT 0, is_emote INTEGER DEFAULT 0, is_from_me INTEGER DEFAULT 0, is_empty INTEGER DEFAULT 0, is_delayed INTEGER DEFAULT 0, is_auto_reply INTEGER DEFAULT 0, is_prepared INTEGER DEFAULT 0, is_read INTEGER DEFAULT 0, is_system_message INTEGER DEFAULT 0, is_sent INTEGER DEFAULT 0, has_dd_results INTEGER DEFAULT 0, is_service_message INTEGER DEFAULT 0, is_forward INTEGER DEFAULT 0, was_downgraded INTEGER DEFAULT 0, is_archive INTEGER DEFAULT 0, cache_has_attachments INTEGER DEFAULT 0, cache_roomnames TEXT, was_data_detected INTEGER DEFAULT 0, was_deduplicated INTEGER DEFAULT 0, is_audio_message INTEGER DEFAULT 0, is_played INTEGER DEFAULT 0, date_played INTEGER, item_type INTEGER DEFAULT 0, other_handle INTEGER DEFAULT 0, group_title TEXT, group_action_type INTEGER DEFAULT 0, share_status INTEGER DEFAULT 0, share_direction INTEGER DEFAULT 0, is_expirable INTEGER DEFAULT 0, expire_state INTEGER DEFAULT 0, message_action_type INTEGER DEFAULT 0, message_source INTEGER DEFAULT 0, associated_message_guid TEXT, associated_message_type INTEGER DEFAULT 0, balloon_bundle_id TEXT, payload_data BLOB, expressive_send_style_id TEXT, associated_message_range_location INTEGER DEFAULT 0, associated_message_range_length INTEGER DEFAULT 0, time_expressive_send_played INTEGER, message_summary_info BLOB);
CREATE INDEX message_idx_is_read ON message(is_read, is_from_me, is_finished);
CREATE INDEX message_idx_handle_id ON message(handle_id);
CREATE INDEX message_idx_failed ON message(is_finished, is_from_me, error);
CREATE INDEX message_idx_associated_message ON message(associated_message_guid);
CREATE INDEX message_idx_handle ON message(handle_id, date);
CREATE INDEX message_idx_date ON message(date);
CREATE INDEX message_idx_expire_state ON message(expire_state);
CREATE INDEX message_idx_other_handle ON message(other_handle);
CREATE INDEX message_idx_was_downgraded ON message(was_downgraded);
CREATE TRIGGER add_to_deleted_messages AFTER DELETE ON message BEGIN     INSERT INTO deleted_messages (guid) VALUES (OLD.guid); END;
CREATE TRIGGER delete_associated_messages_after_delete_on_message AFTER DELETE ON message BEGIN DELETE FROM message WHERE (OLD.associated_message_guid IS NULL AND associated_message_guid IS NOT NULL AND guid = OLD.associated_message_guid); END;
CREATE TRIGGER after_delete_on_message AFTER DELETE ON message BEGIN     DELETE FROM handle         WHERE handle.ROWID = OLD.handle_id     AND         (SELECT 1 from chat_handle_join WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL     AND         (SELECT 1 from message WHERE handle_id = OLD.handle_id LIMIT 1) IS NULL     AND         (SELECT 1 from message WHERE other_handle = OLD.handle_id LIMIT 1) IS NULL; END;

字段说明:

字段	类型	说明
ROWID	INTEGER	消息唯一 ID
guid	TEXT	消息的全局唯一标识符
handle_id	INTEGER	联系人 ID，关联 handle 表的 ROWID
text	TEXT	消息正文
service	TEXT	服务类型（iMessage 或 SMS 等）
account	TEXT	发送账号（Apple ID 或手机号）
date	INTEGER	消息发送时间（2001-01-01起纳秒数）
date_read	INTEGER	被读取的时间戳（纳秒）
date_delivered	INTEGER	被送达的时间戳（纳秒）
is_from_me	INTEGER	是否为自己发送（1=是）
is_sent	INTEGER	是否发送（1=是）
is_delivered	INTEGER	是否送达（1=是）
is_read	INTEGER	是否已读（1=是）
associated_message_guid	TEXT	引用的消息 GUID（例如回复消息）
error	INTEGER	错误状态代码
cache_roomnames	TEXT	群聊标识
destination_caller_id	TEXT	接收方 Caller ID
group_title	TEXT	群聊标题（如果有）

关联联系人表信息
 .schema handle
CREATE TABLE handle (ROWID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, id TEXT NOT NULL, country TEXT, service TEXT NOT NULL, uncanonicalized_id TEXT, UNIQUE (id, service) );
列名	说明
ROWID	唯一标识符
id	手机号 / Apple ID（例如 +8613812345678 或 example@icloud.com）
country	国家代码
service	iMessage / SMS 等服务类型
uncanonicalized_id	规范化前的号码（有时为空）

在 iMessage 数据库 (chat.db) 中，消息的内容和类型信息分布在两个表里：

message 表：存储消息文本、发送信息、状态等

attachment 表：存储附件文件路径和类型

message_attachment_join 表：连接 message 和 attachment 表（多对多关系）

 .schema message_attachment_join
CREATE TABLE message_attachment_join (message_id INTEGER REFERENCES message (ROWID) ON DELETE CASCADE, attachment_id INTEGER REFERENCES attachment (ROWID) ON DELETE CASCADE, UNIQUE(message_id, attachment_id));
CREATE INDEX message_attachment_join_idx_attachment_id ON message_attachment_join(attachment_id);
CREATE INDEX message_attachment_join_idx_message_id ON message_attachment_join(message_id);
CREATE TRIGGER after_insert_on_message_attachment_join AFTER INSERT ON message_attachment_join BEGIN     UPDATE message       SET cache_has_attachments = 1     WHERE       message.ROWID = NEW.message_id; END;
CREATE TRIGGER after_delete_on_message_attachment_join AFTER DELETE ON message_attachment_join BEGIN     DELETE FROM attachment         WHERE attachment.ROWID = OLD.attachment_id     AND         (SELECT 1 from message_attachment_join WHERE attachment_id = OLD.attachment_id LIMIT 1) IS NULL; END;

 .schema attachment
CREATE TABLE attachment (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, guid TEXT UNIQUE NOT NULL, created_date INTEGER DEFAULT 0, start_date INTEGER DEFAULT 0, filename TEXT, uti TEXT, mime_type TEXT, transfer_state INTEGER DEFAULT 0, is_outgoing INTEGER DEFAULT 0, user_info BLOB, transfer_name TEXT, total_bytes INTEGER DEFAULT 0, is_sticker INTEGER DEFAULT 0, sticker_user_info BLOB, attribution_info BLOB, hide_attachment INTEGER DEFAULT 0);
CREATE TRIGGER after_delete_on_attachment AFTER DELETE ON attachment BEGIN   SELECT delete_attachment_path(OLD.filename); END;
CREATE TRIGGER before_delete_on_attachment BEFORE DELETE ON attachment BEGIN   SELECT before_delete_attachment_path(OLD.ROWID, OLD.guid); END;

表结构

1. 关联表结构
message_attachment_join
字段	说明
message_id	对应 message.ROWID
attachment_id	对应 attachment.ROWID
attachment
字段	说明
ROWID	附件 ID
filename	附件路径
mime_type	附件类型，例如 public.jpeg, public.png
transfer_name	文件原始名称
transfer_size	文件大小
total_bytes	文件字节数

测试sql

export LANG=zh_CN.UTF-8
sqlite3 /Users/wx/Library/Messages/chat.db

.headers on
.mode column
长文本
使用 .mode list 或 .mode line

单表查询，
select ROWID as "消息唯一ID",account as "发送账号",handle_id as "联系人ID",text as "消息正文 ", service as "服务类型",is_sent as "是否发送" ,is_delivered as "是否送达",is_read as  "是否已读" from message;

关联handle表查询出关联的联系人信息

 select m.ROWID as "消息唯一ID",m.account as "发送账号",h.id as "联系人ID",m.text as "消息正文 ", m.service as "服务类型",m.is_sent as "是否发送" ,m.is_delivered as "是否送达",m.is_read as  "是否已读" from  message m LEFT JOIN  handle h ON  m.handle_id = h.ROWID



 字段对应关系
message → handle

message.handle_id → handle.ROWID

用于表示消息对应的联系人（收件人）

handle.id 就是手机号或 Apple ID

示例 SQL：
SELECT m.text, h.id AS contact
FROM message m
LEFT JOIN handle h ON m.handle_id = h.ROWID;

message → attachment

一个消息可能有多个附件（图片/视频），一个附件也可能关联多个消息

通过 中间表 message_attachment_join 建立关系：

========================================================================
message
  | (handle_id)
  v
handle

message
  | (ROWID)
  v
message_attachment_join
  | (attachment_id)
  v
attachment
每条消息可能对应一个 handle（接收者）

每条消息可以关联多条 attachment（通过 message_attachment_join）

每个附件也可能被多条消息引用（例如转发、群发场景）

=========================================================================

